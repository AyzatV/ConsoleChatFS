# ConsoleChatFS
***
##### C++ console app for simple chat using file system (OS Linux)
***
#### Содержание файла README:
+ [Назначение проекта](#P1)
+ [Постановка задачи](#P2)
+ [Описание выбранной идеи решения](#P3)
+ [Составные части проекта](#P4)
+ [Работа с приложением](#P5)
+ [Makefile](#P6)

<a name="P1"></a>
#### Назначение проекта
Данное приложение является результатом выполнения задания 18.12.1 курса Skillfactory "Разработчик на С++".

Для выполнения задания необходимо было доработать итоговый проект по первому разделу курса, адаптированный под ОС Linux, с использованием файлов для хранения массивов пользователей и сообщений.

<a name="P2"></a>
#### Постановка задачи
В соответствии с заданием необходимо было создать консольное приложение для
чата со следующим функционалом:

* регистрация пользователей - логин, пароль, имя
* вход в чат по логину/паролю
* отправка сообщений конкретному пользователю
* обмен сообщениями между всеми пользователями чата одновременно
* выгрузка массивов пользователей и сообщений в файлы при завершении работы
программы и загрузка этих массивов из файлов при запуске программы

При этом обязательным условием было использование файловой системы для
ограничения прав доступа к файлам, в которые записываются массивы данных,
а также составление специализированного файла **Makefile** для сборки проекта
с помощью утилиты **make**.

Использоваться приложение должно было в одном общем консольном окне разными участниками чата. Таким образом, предполагалось, что пользование чатом осуществляется последовательно - одним участником чата в каждый момент времени.

<a name="P3"></a>
#### Описание выбранной идеи решения
Для реализации поставленной задачи выбрано решение, в котором используются отдельный массивы для хранения информации о пользователях и сообщениях. В качестве контейнера для данных массивов использовался самостоятельно разработанный шаблонный класс **`std::vectorf<T>`**, являющийся дочерним классом от стандартного контейнера STL **`std::vector<T>`**. Реализация функционала приложения осуществляется с помощью специально разработанного управляющего класса, исполняющего команды пользователя из определенного набора команд, который обеспечивает весь заданный функционал приложения. Для записи в файл и чтения из файлов пользовательских типов данных был разработан шаблонный класс **`uploader<T>`**.

Кроме функционала приложения, который является обязательным, реализован также дополнительный функционал:

* фиксация времени отправки сообщения
* фиксация факта прочтения сообщения получателем (сообщения помечаются как прочитанные)
* возможность вывода только непрочитанных пользователем сообщений

<a name="P4"></a>
#### Составные части проекта

Далее представлено описание компонентов проекта. Назначение используемых в них функций поясняется, там где это необходимо, в комментариях к коду с реализацией этих функций.

##### Класс `std::vectorf<T>`
Данный шаблонный класс реализован как дочерний класс от класса STL **`std::vector`** с дополнительным функционалом и используется как контейнер для хранения массивов данных, имеющих тип **`T`**.

Кроме стандартного для контейнера **`std::vector`** функционала, в нем дополнительно реализованы функции отбора по заданному критерию: **`getSelection`** - для выборки массива значений и **`tryGetOne`** - для выбора отдельного элемента массива. При этом конкретный критерий реализуется за счет соответствующей функции (предиката), передаваемой в указанные функции по указателю. Для возможности внесения изменений в выбранные элементы массива функция **`getSelection`** возвращает массив ссылок на элементы исходного массива. Для реализации возможности возврата массива ссылок используется контейнер **`std::vector`**.

##### Класс `uploader<T>`
Этот шаблонный класс содержит две функции **`bool data_saved()`** и
**`bool data_loaded()`** для записи и загрузки соответственно массивов пользовательских типов данных. При этом в качестве параметра в эти функции передаются специфические для данного типа данных функции конвертирования, одна из которых преобразует данный тип в массив строк для записи в файл, а другая - осуществляет обратное преобразование массива строк в пользовательский тип данных.

##### Класс `Users`
Класс предназначен для управления массивом зарегистрированных пользователей. В данном классе используется структура **`User`**, представляющая тип переменных, которые хранятся в массиве. Полями этой структуры являются три строковые переменные - логин, имя и пароль пользователя, а также переменная типа **`TimeData`**, используемая для фиксации времени последнего просмотра общего чата данным пользователем с помощью функции
**`void Users::fixTime(size_t index)`**.

<a name="Mess"></a>
##### Класс `Messages`
По аналогии с предыдущим классом, этот класс предназначен для управления массивом сообщений. В данном классе используется структура **`Message`**, представляющая тип переменных, которые хранятся в массиве. Полями этой структуры являются три строковые переменные - текст сообщения, "полное" имя отправителя, "полное" имя получателя, переменная типа **`TimeData`**, используемая для фиксации времени отправки сообщения, а также переменная с именем **`fresh`** типа **`bool`**, которая имеет значение **`true`**, если сообщение не прочитано получателем, и **`false`**, если уже прочитано.

"Полное" имя пользователя формируется как "имя--логин" и используется для возможности однозначной идентификации пользователя, поскольку потенциально имена некоторых пользователей могут совпадать.

Вывод сообщений осуществляется через перегрузку оператора вывода **`<<`** в следующем формате:

отправлено [дата и время] пользователем [имя--логин] для пользователя [имя--логин]

[сообщение прочитано получателем] - выводится, если прочитано

[текст сообщения]

##### Класс `TimeData`
Данный класс был разработан как пользовательский тип данных "дата+время", поскольку в стандартном С++ такой тип данных отсутствует. Этот класс дает возможность фиксировать время отправки и прочтения сообщений, а также выводить это время в виде строки в заданном формате.

##### Класс `ChatBot`
Этот класс является контролером управления работой приложения. Управление осуществляется с помощью команд, определенных в перечислении **`CommandType`**. В файле **ChatBot.h**, где дается определение этого перечисления, назначение команд дается в комментариях к элементам данного перечисления, значения которых являются одновременно символами команд, которые вводит пользователь.

Для самих команд используется структура **`CB_command`**, одним из полей которой является тип команды (тип **`CommandType`**), а другим - строковая переменная, используемая как параметр команды. Параметр команды используется только для некоторых команд, для остальных данное поле является пустым. Для удобства пользования данной структурой реализована перегрузка операторов ввода **`>>`** и вывода **`<<`**. Для повышения надежности работы приложения перегрузка оператора ввода реализована таким образом, что распознавание вводимой команды может происходить даже при вводе посторонних символов. Если распознать вводимую команду все-таки не удалось, то это трактуется как команда **'?'**, которая используется для вывода списка всех возможных команд с их описанием. 

Данная пользовательская версия описания команд представлена в теле функции **`showHelp()`** в файле **ChatBot.cpp**. Эта функция активируется при запуске программы, а также в любой момент работы с программой по команде **'?'**.

Описание всех возможных команд здесь не приводится, поскольку, как это сказано выше, такое описание достаточно подробно дано в файлах **ChatBot.h** и **ChatBot.cpp**. Кроме того, об этих командах говорится в контексте следующего раздела.

<a name="P5"></a>
#### Работа с приложением
Во время запуска приложения загружаются массивы пользователей и сообщений. При этом файлы уже содержат 3 зарегистрированных пользователей, каждый из которых уже написал по 3 сообщения (1 в общий чат, 2 - другим пользователям). Это дает возможность для более быстрого опробования и тестирования приложения, поскольку уже не надо вводить много пользователей. Кроме того, можно уже входить в систему и писать сообщения от имени имеющихся пользователей. Имена и логины зарегистрированных пользователей выводятся по команде **'u'**. Пароли уже имеющихся при запуске пользователей приведены в файле **chat_users.txt** (следующее поле после имени пользователя) и представляют собой их написанные в обратном порядке логины.

Как уже говорилось выше, при запуске приложения выводится список возможных команд пользователя, который также можно вывести в любой момент работы с приложением по команде **'?'**.

Для регистрации нового пользователя используется команда **'r'**. После ввода пользователем логина, пароля и имени, они выводятся пользователю для их подтверждения на случай ошибочного ввода. После подтверждения введенных регистрационных данных пользователем, они вносятся как новый элемент в массив пользователей, а данный пользователь считается уже вошедшим в систему и может работать с чатами.

Для входа в систему зарегистрированного пользователя предназначена команда **'i'**, параметром которой является логин пользователя. Параметр команды вводится через пробел после символа команды, хотя будет воспринят приложением, если даже пользователь не ввел этот пробел. В этом случае все символы до следующего пробела будут восприняты как параметр команды. Если параметр не был введен, ввод логина запрашивается отдельно. После ввода логина запрашивается ввод пароля. Если логин или пароль не были найдены в массиве пользователей, либо они не соответствуют друг другу, то входа в систему не происходит и выводится сообщение о несоответствии регистрационных данных. После исполнения данной команды пользователю выводится сообщение, что он вошел в систему.

Для выхода из системы применяется команда **'o'**. После исполнения данной команды пользователю выводится сообщение, что он вышел из системы.

Для вывода чата используется команда **'c'**. Параметром данной команды является логин или имя пользователя, чат с которым должен быть выведен. Если параметр отсутствует, то выводится общий чат. При выводе чата выводятся все сообщения в этом чате в хронологическом порядке. Формат вывода сообщений указан в разделе данного файла, где описывается класс [**`Messages`**](#Mess). После вывода сообщений чата пользователь может написать текст своего сообщения в этот чат. После отправки сообщения оно выводится в установленном формате, указанном выше, а пользователю предлагается ввести следующую команду.

Используя команду **'m'** пользователь имеет возможность написать сообщение и без вывода всего чата. Параметром данной команды является логин или имя получателя сообщения. Если параметр не был введен, то сообщение адресуется всем, т.е. в общий чат.

Для просмотра свежих еще не прочитанных сообщений используется команда **'s'**. Параметром данной команды является логин или адрес отправителя сообщений. Если параметр не был введен, то выводятся все непрочитанные сообщения, включая сообщения общего чата. При этом сначала отдельной группой выводятся сообщения общего чата, а затем другой группой - сообщения от других пользователей. Все сообщения выводятся в хронологическом порядке, в котором они хранятся в массиве сообщений.

Команды **'o'**, **'c'**, **'m'** и **'s'**, предназначенные для выхода из системы и работы с чатами, не будут исполнены, если текущий пользователь не вошел в систему. Вместо исполнения команды будет выведена информация о необходимости войти в систему для возможности использования данной команды.

Для прекращения работы с приложением используется команда **'q'**. Непосредственно перед завершением работы программы производится запись в файлы **chat_users.txt** и **chat_mess.txt** актуальных массивов пользователей и сообщений.

<a name="P6"></a>
#### Makefile
Данный файл был составлен на основе анализа информации, полученной из интернет и специализированных книг по данной тематике, исходя из условия его максимально возможной универсальности для сборки типовых проектов под ОС Linux. В полученном варианте файла необходимо лишь в одной его строке внести имя формируемого исполняемого файла и разместить в одном каталоге с этим файлом все необходимые исходные файлы. Других файлов, не относящихся к данному проекту в этом каталоге быть не должно.
